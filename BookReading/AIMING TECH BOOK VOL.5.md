## Netcode for GameObjectsで作る遅延を感じにくいゲーム設計


本書は、Aimingに所属するエンジニア有志が、日々の業務や個人の興味から得た技術的な知見や取り組みを共有する「Aiming Tech Book」の第5巻です。コンセプトは「Development pattern, idea, tutorial, and favorite!」で、実務に直結するノウハウから少しマニアックな技術まで幅広いテーマが収録されています。

## まえがき
- メモ：業務に使えそうなところだけ自分でメモ書いてる
	- １章は一部内容が勉強になったのでメモ書いてる
- オンラインゲーム開発に関わる幅広いテーマが収録されている。

## 第 1章 Netcode for GameObjectsで作る遅延を感じにくいゲーム設計

### 解決したいこと

-　昨今のゲームにおけるオンライン機能・マルチプレイは標準的な機能になっている。
	- 実際確かにそうなっていると感じる
		- ただ、単独でやることが前提のゲームは廃れてはいないが、そのためにはゲームに激しく没入させるための非常に質の高いシナリオが要求されているように感じる（メタルギア、SEKIROなど）
	
- 特にスマートフォンゲームにおいては、回線品質のばらつきにおいて遅延が発生しやすく、UXに多大な影響を及ぼしている。
- その中で、モバイル回線のような厳しい回線環境下においても、遅延を感じにくくしたい
### 手法

- Unity公式のマルチプレイ開発ライブラリであるNetcode for GameObjectsを活用し、これを解決する。
- サンプルゲームとしてオンラインシューティングゲームを題材にしている。
- Netcode for GameObjectsはデフォルトでクライアント/サーバ型のトポロジーを採用する。
	- [トポロジーとは](https://www.monodukuri.com/gihou/article/4716)
		数学における一分野であり、空間の形状や物体の連続的な変形に焦点を当てている。
		本質としては変形可能性。物体の形状が伸ばされようと曲げられようと、その基本的性質には変化がないことを扱う。
		物体がどのように連結されているか、穴がいくつあるかなどの連続的な変形によって変わらない特性を研究する。
		これは数学における基本的概念を形成しており、多くの他分野に応用されている
- これはGameObject単位、Component単位の同期が容易に実現可能であるとされる
	- 細かく同期の指定ができることによるメリットが何かしらあるはず
		- サッカーのゲーム作ったらサッカーボールだけは絶対に同期させとかないとやばいみたいなの？
- 全クライアントはサーバに接続され、ゲーム状態はサーバが管理する。ホストプレイヤーがサーバを担うListen Serverを前提とする
	- 一般的なオンラインゲームサーバっぽい？
	- これいっちゃんイメージしやすいのはマイクラかも
#### Listen Serverの利点・欠点
- 利点：不正防止が容易
	- サーバ側がゲームの同期を管理。不正コマンドの検知と排除を行う
	- クライアント同士が直接通信しないため、データ改竄のリスクが低減
- 欠点：遅延が容易に発生する
	- 全操作がサーバを経由するため、レスポンスが遅くなりやすい
	- クライアントの入力はサーバを往復するため、遅延が大きくなる
- 遅延対策として、「完全な同期」ではなく「見た目上の同期」を重視し、適切な予測と即時フィードバックを組み合わせる方法を紹介している。

## 第 2章 Unityのパッケージ開発における活用実践
- メモ:
- Unityにおけるパッケージは、関連するクラス、インターフェース、リソースなどをグループ化し、特定の機能を提供したりコードをモジュール化したりするコンテナである。
- パッケージ開発のメリットとして、コードとアセットの再利用性向上、プロジェクトのモジュール化と関心の分離、チーム開発の効率化などが挙げられている。
- Unity Package Manager (UPM) を使用してパッケージを一元管理できる。
- パッケージの導入方法には、Unity Registry、スコープ付きレジストリ (OpenUPMなど)、Git URL、ローカルディスク、埋め込みパッケージがある。
- パッケージの基本構造は、`package.json`ファイルと標準的なフォルダ構成（Runtime, Editor, Tests, Documentation~, Samples~など）で構成される。
- `package.json`にはパッケージ名、バージョン、表示名、説明、依存関係などが記述される。
- Assembly Definition (`.asmdef`) ファイルは、スクリプトグループをアセンブリに分割し、依存関係を管理する役割を持つ。
- ローカル開発ワークフローとして、リポジトリを分離する推奨アプローチや、ライブ参照（file:パス、シンボリックリンク）、埋め込みパッケージワークフローが紹介されている。
- パッケージ開発のベストプラクティスとして、依存関係の管理、セマンティックバージョニング (SemVer) の遵守、テストの作成と実行、ドキュメンテーション（README.md, CHANGELOG.md, LICENSE.md, Documentation~）、利用例 (Samples~) の提供が重要であると述べられている。
- プロジェクトにおけるパッケージ活用は、クリーンアーキテクチャやSOLID原則、特に依存性逆転の原則 (DIP) を適用しやすくし、機能ベースのパッケージングによるモジュール化にも繋がる。

## 第 3章 ShaderGraph ノード再現で学ぶ GLSL 基礎
- メモ:
- ShaderGraphのノード再現を通じて、シェーダー言語であるGLSLの基礎を学ぶことを目的としている。
- 環境構築として、VSCodeにShader Toy拡張機能を導入し、GLSLのプレビューを確認する方法が紹介されている。
- 点を描写する基本的な図形描画から解説が始まっている。
- レイマーチングの利用についても触れられている。
- ノイズ（ボロノイノイズ、シンプレックスノイズ、パーリンノイズなど）についても少し扱っている.
- 最終目標として、ShaderGraphのノード（Ellipse, Rectangle, Polygon）の再現、ボロノイノイズ、歪みシェーダー、ハーフトーンの作成を掲げている。

## 第 4章 VFXGraphに自作の Templateを追加する
- メモ:
- Unity 6000.0以降で追加されたVFX Graphのテンプレート機能について解説している。
- 標準機能だけでは煩雑なテンプレートの登録・編集・削除を効率化するためのエディタツールの制作とその実装例を紹介している。
- テンプレートの登録には`VFXTemplateHelper.TrySetTemplate()`を使用し、テンプレートの情報 (`VFXTemplateDescriptor`構造体) を渡す。
- テンプレートの情報には、名前、カテゴリ名、説明、アイコン、サムネイルが含まれる。
- 既存のテンプレート確認には`VFXTemplateHelper.TryGetTemplate()`を使用する。
- テンプレート情報はVFXGraphアセットの`.meta`ファイルに書き込まれるため、削除するにはこの情報を空にする。
- ツール実装のコード例や、テンプレート登録・削除のUIについても紹介している。

## 第 5章 A*アルゴリズムを使って経路探索を実装
- メモ:
- 経路探索に用いられるNavMeshの理解を深めるため、その基礎技術であるA*アルゴリズム（エースターアルゴリズム）を用いた経路探索の実装について解説している。
- A*アルゴリズムは、スタート地点からゴール地点まで最も効率の良い道を見つけ出す探索アルゴリズムである。
- 探索の評価基準として、Gコスト（スタートからの距離）、Hコスト（ゴールまでの推定距離）、Fコスト（Gコスト+Hコスト）を使用する。Fコストが低いノードを優先的に探索する。
- Unity C#での開発経験があり、NavMeshを使った経路探索の経験がある読者を対象としている。

## 第 6章 マーチングキューブ法を用いてランタイムで穴を掘る
- メモ:
- マーチングキューブ法を用いてランタイム（実行時）で地形に穴を掘る実装について解説している。
- マーチングキューブ法は、ボクセルデータからメッシュを生成するアルゴリズムである。
- 個々のボクセル（キューブ）の頂点状態（内側か外側か）を8ビットの2進数（0～255）で表現し、これをインデックスとして256通りのテーブルを参照してメッシュの頂点と三角形ポリゴンを生成するアルゴリズムが解説されている。

## 第 7章 DIコンテナ の作り方
- メモ:
- ソフトウェアの柔軟性を高めるDIコンテナ（依存性注入コンテナ）の仕組みとその作り方について解説している。
- DIコンテナとは何か、依存性解決のためのパターンの一つであることなどが説明されている。
- 本章で作成するDIコンテナは入門的な実装だが、インスタンスのキャッシュや連鎖した依存関係の解決といった実用的なDIコンテナに必要な機能の拡張についても触れられている。
- `InjectAttribute`を使ったメソッドへの注入から始まり、キャッシュ機能や依存注入済みのインスタンス管理のための`CachedInstance`クラスの導入などがコード例とともに示されている。
- Unityにおける`SerializeField`との違いに触れ、DIコンテナがランタイムにおける動的な依存注入やテスト時のモック利用に有効であることを説明している。
- 著者が公開しているDIフレームワーク「Doinject」についても紹介されている。DIは設計について深く考えることに繋がる創造的な活動であると述べている。

## 第 8章 C# Source Generator 入門
- メモ:
- C#のSource Generatorは、コンパイル時にコードを自動生成する機能であり、コードの簡素化、パフォーマンス向上、型安全性向上といったメリットがある。
- Source Generatorの中枢を成す構文木（Syntax Tree）とセマンティックモデル（Semantic Model）の基礎知識を紹介している。
- 構文木はソースコードの階層的な構造（ノード、トークン、トリビア）を表す。Visual StudioのSyntaxVisualizerで確認できる。
- セマンティックモデルは構文木を基にコードの意味情報（型、名前空間、参照関係など）を解析するモデルで、シンボル（ISymbol）を通じて要素の情報にアクセスできる。
- Source Generatorライブラリの実装方法として、.NET Compiler Platform SDKのインストール、プロジェクトの用意（.NET Standard 2.0のクラスライブラリ）、csprojへの設定追加（LangVersion, IsRoslynComponent）、`Microsoft.CodeAnalysis.CSharp`パッケージ参照などが解説されている。
- Unityで使用している`Microsoft.CodeAnalysis.CSharp.dll`のバージョンに合わせたライブラリ作成が必要であることにも触れている。
- デバッグ環境の構築方法（Analyzerとしての参照、デバッグ起動プロファイル設定）も説明されている。
- `IIncrementalGenerator`インターフェースを実装し、`Initialize`メソッドでソース生成処理を登録する。特定の属性が付与されたpartialクラスにメソッドを追加するサンプルコードが示されている。
- UnityでSource Generatorライブラリを利用するには、出力されたdllをインポートし、Import Settingsでプラットフォームのチェックを外し、Asset Labelsに`RoslynAnalyzer`を設定する必要がある。
- Source Generatorはアセンブリ単位でソース生成を行うため、複数のアセンブリから参照されるコードを生成する場合に警告 (CS0436) が発生することがある。

## 第 9章 RunnerDeployment vs AutoscalingRunnerSet
- メモ:
- GitHub Actionsのself-hosted runnerをKubernetes上で運用する際の、RunnerDeploymentベースの構成とAutoscalingRunnerSetを用いた構成を比較検討している。
- GitHub Actionsのself-hosted runnerは、特にKubernetes上での運用においてスケーラビリティや柔軟性の利点がある。
- 前回の記事（Aiming Tech Book Vol.3）ではRunnerDeploymentを使った構築方法が紹介されていた。
- RunnerDeploymentの課題として、常時最低1つのnodeおよびpodが起動しているため、未使用時間でもコストがかかる点が挙げられている。
- AutoscalingRunnerSetはListenerが要求に応じてScaleを変更するため、podおよびnodeのmin scaleを0にできるメリットがある。
- RunnerDeploymentのデメリットは常時起動によるコスト、Preemptible VM（またはSpot VM）との相性の悪さ（runner稼働中にノードが停止する可能性がある）である。
- AutoscalingRunnerSetのメリットは要求時起動によるコスト削減だが、デメリットは要求から起動まで時間がかかること（体感2～3分）とListener podが常時起動する必要があることである。
- Preemptible/Spot VMとARC（AutoscalingRunnerSet）について、RunnerDeployment運用中にpodの強制停止が頻繁に発生したが、AutoscalingRunnerSet（かつSpot VMへの変更）移行後は劇的に減少したという運用で得られた知見が共有されている。これはRunnerDeploymentではノードが24時間を超えて起動し続けることが多かったためではないかと推測されている。
