# æŠ€è¡“ä»•æ§˜ (Hono + Cloudflare Workersç‰ˆ)

## ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### å…¨ä½“æ§‹æˆ
```
LINE App
â””â”€â”€ LIFF App (React + TypeScript)
    â”œâ”€â”€ LIFF SDK v2.x
    â”œâ”€â”€ æ—¢å­˜UI (Radix UI + Tailwind)
    â””â”€â”€ REST API
        â””â”€â”€ Cloudflare Workers (Hono)
            â”œâ”€â”€ LINEèªè¨¼
            â”œâ”€â”€ Cloudflare D1 Database
            â”œâ”€â”€ Cloudflare Cron Triggers
            â””â”€â”€ LINE Bot (é€šçŸ¥ã®ã¿)
```

### ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼
1. **èªè¨¼**: LIFF â†’ LINEèªè¨¼ â†’ Cloudflare Workers
2. **æ“ä½œ**: LIFF App â†’ Hono API â†’ D1 Database
3. **é€šçŸ¥**: Cloudflare Cron â†’ LINE Bot â†’ Push Message

## ğŸ’» ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### åŸºç›¤æŠ€è¡“
- **Framework**: React 19
- **Language**: TypeScript
- **Build Tool**: Vite
- **Package Manager**: npm

### UI/UXãƒ©ã‚¤ãƒ–ãƒ©ãƒª
- **Component Library**: Radix UI
- **Styling**: Tailwind CSS
- **Icons**: Lucide React
- **Charts**: Recharts

### çŠ¶æ…‹ç®¡ç†
- **Server State**: TanStack Query
- **Client State**: Zustand
- **Forms**: React Hook Form + Zod validation

### LIFFçµ±åˆ
- **SDK**: @line/liff v2.x
- **èªè¨¼**: LINE Login
- **APIé€šä¿¡**: Fetch API with LIFF access token

### é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆ
- **Testing**: Vitest + Testing Library + Playwright
- **Linting**: ESLint
- **Type Checking**: TypeScript

## ğŸ”§ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ (Hono + Cloudflare)

### APIè¨­è¨ˆ (Hono + Cloudflare Workers)
```typescript
// src/index.ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { jwt } from 'hono/jwt'
import { authRoutes } from './routes/auth'
import { medicinesRoutes } from './routes/medicines'
import { schedulesRoutes } from './routes/schedules'
import { logsRoutes } from './routes/logs'

type Bindings = {
  DB: D1Database
  LINE_CHANNEL_ACCESS_TOKEN: string
  LINE_CHANNEL_SECRET: string
  JWT_SECRET: string
  LIFF_ID: string
}

const app = new Hono<{ Bindings: Bindings }>()

// CORSè¨­å®š
app.use('*', cors({
  origin: ['https://your-liff-app.vercel.app'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization']
}))

// ãƒ«ãƒ¼ãƒˆè¨­å®š
app.route('/api/auth', authRoutes)
app.route('/api/medicines', medicinesRoutes)
app.route('/api/schedules', schedulesRoutes)
app.route('/api/logs', logsRoutes)

// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
app.get('/health', (c) => {
  return c.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    worker: 'cloudflare-workers'
  })
})

export default app
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
- **Cloudflare D1**: ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
- **é–‹ç™º**: ãƒ­ãƒ¼ã‚«ãƒ«D1 / SQLite
- **æœ¬ç•ª**: Cloudflare D1 (ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ†æ•£)
- **ORM**: Drizzle ORM (Cloudflare Workersæœ€é©åŒ–)

### èªè¨¼ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- **LINEèªè¨¼**: LINE Login API
- **ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼**: LINE Profile API
- **ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**: Hono JWT middleware
- **ã‚¨ãƒƒã‚¸ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: Cloudflare WAF

### é€šçŸ¥ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©
- **LINE Bot API**: ãƒ—ãƒƒã‚·ãƒ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- **ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©**: Cloudflare Cron Triggers
- **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**: Cloudflare KV (ã‚­ãƒ£ãƒƒã‚·ãƒ¥)
- **ã‚­ãƒ¥ãƒ¼**: Cloudflare Queues

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ (Cloudflare D1)

### Drizzle ORM ã‚¹ã‚­ãƒ¼ãƒ
```typescript
// src/db/schema.ts
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core'
import { relations } from 'drizzle-orm'

export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  lineUserId: text('line_user_id').notNull().unique(),
  displayName: text('display_name').notNull(),
  pictureUrl: text('picture_url'),
  timezone: text('timezone').default('Asia/Tokyo'),
  notificationEnabled: integer('notification_enabled', { mode: 'boolean' }).default(true),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date())
})

export const medicines = sqliteTable('medicines', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  description: text('description'),
  dosage: text('dosage').notNull(),
  unit: text('unit').notNull(),
  color: text('color').default('#ec4899'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date())
})

export const medicationSchedules = sqliteTable('medication_schedules', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  medicineId: integer('medicine_id').notNull().references(() => medicines.id, { onDelete: 'cascade' }),
  time: text('time').notNull(), // HH:MM format
  dosage: text('dosage').notNull(),
  frequency: text('frequency').default('daily'), // daily, weekly, custom
  daysOfWeek: text('days_of_week'), // JSON array
  breakPeriods: text('break_periods'), // JSON array
  isActive: integer('is_active', { mode: 'boolean' }).default(true),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date())
})

export const medicationLogs = sqliteTable('medication_logs', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  scheduleId: integer('schedule_id').notNull().references(() => medicationSchedules.id, { onDelete: 'cascade' }),
  scheduledAt: integer('scheduled_at', { mode: 'timestamp' }).notNull(),
  takenAt: integer('taken_at', { mode: 'timestamp' }),
  status: text('status').notNull(), // taken, missed, delayed
  notes: text('notes'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date())
})

// ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©
export const usersRelations = relations(users, ({ many }) => ({
  medicines: many(medicines)
}))

export const medicinesRelations = relations(medicines, ({ one, many }) => ({
  user: one(users, {
    fields: [medicines.userId],
    references: [users.id]
  }),
  schedules: many(medicationSchedules)
}))

export const schedulesRelations = relations(medicationSchedules, ({ one, many }) => ({
  medicine: one(medicines, {
    fields: [medicationSchedules.medicineId],
    references: [medicines.id]
  }),
  logs: many(medicationLogs)
}))

export const logsRelations = relations(medicationLogs, ({ one }) => ({
  schedule: one(medicationSchedules, {
    fields: [medicationLogs.scheduleId],
    references: [medicationSchedules.id]
  })
}))
```

### D1 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
```sql
-- D1 ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
-- migrations/0001_initial.sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  line_user_id TEXT UNIQUE NOT NULL,
  display_name TEXT NOT NULL,
  picture_url TEXT,
  timezone TEXT DEFAULT 'Asia/Tokyo',
  notification_enabled INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE TABLE medicines (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  dosage TEXT NOT NULL,
  unit TEXT NOT NULL,
  color TEXT DEFAULT '#ec4899',
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE medication_schedules (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  medicine_id INTEGER NOT NULL,
  time TEXT NOT NULL,
  dosage TEXT NOT NULL,
  frequency TEXT DEFAULT 'daily',
  days_of_week TEXT,
  break_periods TEXT,
  is_active INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (medicine_id) REFERENCES medicines(id) ON DELETE CASCADE
);

CREATE TABLE medication_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  schedule_id INTEGER NOT NULL,
  scheduled_at INTEGER NOT NULL,
  taken_at INTEGER,
  status TEXT NOT NULL,
  notes TEXT,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (schedule_id) REFERENCES medication_schedules(id) ON DELETE CASCADE
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
CREATE INDEX idx_users_line_user_id ON users(line_user_id);
CREATE INDEX idx_medicines_user_id ON medicines(user_id);
CREATE INDEX idx_schedules_medicine_id ON medication_schedules(medicine_id);
CREATE INDEX idx_schedules_time ON medication_schedules(time);
CREATE INDEX idx_logs_schedule_id ON medication_logs(schedule_id);
CREATE INDEX idx_logs_scheduled_at ON medication_logs(scheduled_at);
```

## ğŸ” èªè¨¼ãƒ•ãƒ­ãƒ¼ (Hono)

### LIFFèªè¨¼ã®å®Ÿè£…
```typescript
// src/lib/liff.ts
import liff from '@line/liff'

export const initializeLiff = async () => {
  try {
    await liff.init({ liffId: import.meta.env.VITE_LIFF_ID! })
    
    if (!liff.isLoggedIn()) {
      liff.login()
      return null
    }
    
    const profile = await liff.getProfile()
    const context = liff.getContext()
    
    return {
      userId: context?.userId,
      profile,
      accessToken: liff.getAccessToken()
    }
  } catch (error) {
    console.error('LIFF initialization failed:', error)
    throw error
  }
}
```

### Honoèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
```typescript
// src/middleware/auth.ts
import { Context, Next } from 'hono'
import { HTTPException } from 'hono/http-exception'
import { drizzle } from 'drizzle-orm/d1'
import { users } from '../db/schema'
import { eq } from 'drizzle-orm'

export async function authMiddleware(c: Context, next: Next) {
  try {
    const authHeader = c.req.header('Authorization')
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new HTTPException(401, { message: 'No valid authorization header' })
    }

    const accessToken = authHeader.substring(7)
    
    // LINE Profile API ã§æ¤œè¨¼
    const profileResponse = await fetch('https://api.line.me/v2/profile', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    })

    if (!profileResponse.ok) {
      throw new HTTPException(401, { message: 'Invalid LINE access token' })
    }

    const profile = await profileResponse.json()
    
    // D1ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ¤œç´¢ã¾ãŸã¯ä½œæˆ
    const db = drizzle(c.env.DB)
    let user = await db.select().from(users).where(eq(users.lineUserId, profile.userId)).get()

    if (!user) {
      const [newUser] = await db.insert(users).values({
        lineUserId: profile.userId,
        displayName: profile.displayName,
        pictureUrl: profile.pictureUrl,
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning()
      user = newUser
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ 
    c.set('user', user)
    c.set('lineProfile', profile)

    await next()
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }
    console.error('Auth middleware error:', error)
    throw new HTTPException(401, { message: 'Authentication failed' })
  }
}
```

## ğŸ“± LIFFè¨­å®š

### LINE Developers Consoleè¨­å®š
```json
{
  "liffId": "your-liff-id",
  "endpointUrl": "https://your-liff-app.vercel.app",
  "scope": ["profile", "openid"],
  "botPrompt": "aggressive",
  "features": {
    "ble": false,
    "qrCodeReader": false
  }
}
```

### Cloudflare Workers ç’°å¢ƒå¤‰æ•°è¨­å®š
```toml
# wrangler.toml
name = "medicine-liff-api"
main = "src/index.ts"
compatibility_date = "2024-11-01"

[env.production.vars]
LIFF_ID = "your-liff-id"

[env.production.secrets]
LINE_CHANNEL_ACCESS_TOKEN = "your-channel-access-token"
LINE_CHANNEL_SECRET = "your-channel-secret" 
JWT_SECRET = "your-jwt-secret"

[[env.production.d1_databases]]
binding = "DB"
database_name = "medicine-db"
database_id = "your-d1-database-id"

# Cron Triggers
[[env.production.triggers]]
crons = ["0 */15 * * * *"] # 15åˆ†æ¯ã«ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼ãƒã‚§ãƒƒã‚¯

[[env.production.triggers]]
crons = ["0 20 * * 0"] # æ¯é€±æ—¥æ›œ20æ™‚ã«ãƒ¬ãƒãƒ¼ãƒˆé€ä¿¡
```

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ (LIFF App)
- **ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ **: Vercel / Netlify
- **ãƒ“ãƒ«ãƒ‰**: Vite build â†’ é™çš„ãƒ•ã‚¡ã‚¤ãƒ«
- **è¦ä»¶**: HTTPSå¿…é ˆ (LIFFè¦ä»¶)
- **CDN**: è‡ªå‹•é…ä¿¡

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ (Cloudflare Workers)
- **ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ **: Cloudflare Workers
- **ãƒ‡ãƒ—ãƒ­ã‚¤**: `wrangler deploy`
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: Cloudflare D1 (ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆ†æ•£)
- **ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©**: Cloudflare Cron Triggers (çµ„ã¿è¾¼ã¿)
- **ã‚¨ãƒƒã‚¸ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯**: ä¸–ç•Œ200ç®‡æ‰€ä»¥ä¸Šã®ã‚¨ãƒƒã‚¸ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

### LINE Botè¨­å®š
- **Webhook URL**: `https://your-worker.your-subdomain.workers.dev/webhook/line`
- **ãƒãƒ£ãƒ³ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³**: Workersç’°å¢ƒå¤‰æ•°ã§ç®¡ç†
- **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸API**: ãƒ—ãƒƒã‚·ãƒ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ä½¿ç”¨

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- **Code Splitting**: React.lazy + Suspense
- **Bundle Analysis**: Bundle Analyzer
- **Image Optimization**: WebPå½¢å¼ã€é©åˆ‡ãªã‚µã‚¤ã‚º
- **Caching**: Service Worker (PWA)

### Cloudflare Workers
- **ã‚¨ãƒƒã‚¸ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°**: ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·å¿œç­”
- **D1ã‚¯ã‚¨ãƒªæœ€é©åŒ–**: é©åˆ‡ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­å®š
- **KVã‚­ãƒ£ãƒƒã‚·ãƒ¥**: é »ç¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
- **Smart Placement**: è‡ªå‹•çš„ãªæœ€é©é…ç½®

### é€šä¿¡æœ€é©åŒ–
- **API Response**: å¿…è¦æœ€å°é™ã®ãƒ‡ãƒ¼ã‚¿
- **Compression**: è‡ªå‹•gzip/brotliåœ§ç¸®
- **HTTP/3**: Cloudflareè‡ªå‹•å¯¾å¿œ
- **ã‚°ãƒ­ãƒ¼ãƒãƒ«CDN**: ã‚¨ãƒƒã‚¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥

## ğŸ”§ Cloudflareã®åˆ©ç‚¹

### ã‚³ã‚¹ãƒˆåŠ¹ç‡
- **å¾“é‡èª²é‡‘**: ä½¿ç”¨ã—ãŸåˆ†ã ã‘ã®æ”¯æ‰•ã„
- **ç„¡æ–™æ **: æœˆé–“10ä¸‡ãƒªã‚¯ã‚¨ã‚¹ãƒˆç„¡æ–™
- **ã‚µãƒ¼ãƒãƒ¼ç®¡ç†ä¸è¦**: ã‚¤ãƒ³ãƒ•ãƒ©é‹ç”¨ã‚³ã‚¹ãƒˆã‚¼ãƒ­

### ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£
- **è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒ«**: ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯æ€¥å¢—ã«è‡ªå‹•å¯¾å¿œ
- **ã‚°ãƒ­ãƒ¼ãƒãƒ«é…ä¿¡**: ä¸–ç•Œä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·
- **é«˜å¯ç”¨æ€§**: 99.99%ã®SLAä¿è¨¼

### é–‹ç™ºåŠ¹ç‡
- **çµ±åˆãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ **: Workersã€D1ã€KVã€QueuesãŒçµ±åˆ
- **é«˜é€Ÿãƒ‡ãƒ—ãƒ­ã‚¤**: æ•°ç§’ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ‡ãƒ—ãƒ­ã‚¤
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ**: è©³ç´°ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ

---

å‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: [[02_è¦ä»¶å®šç¾©]]
æ¬¡ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: [[04_é–‹ç™ºè¨ˆç”»]]
