  private async addToRetryQueue(reminder: any) {
    // å†è©¦è¡Œã‚­ãƒ¥ãƒ¼ã¸ã®è¿½åŠ 
    // Cloudflare Queuesä½¿ç”¨æ™‚ã®å®Ÿè£…ä¾‹
    console.log(`Adding reminder ${reminder.id} to retry queue`)
  }
}
```

## ğŸ“Š é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ

### ã‚·ã‚¹ãƒ†ãƒ ç¨¼åƒãƒ¬ãƒãƒ¼ãƒˆ
```typescript
// operational-reports.ts
export interface SystemReport {
  period: string
  metrics: {
    uptime: number
    totalRequests: number
    averageResponseTime: number
    errorRate: number
    activeUsers: number
  }
  performance: {
    slowestEndpoints: Array<{
      path: string
      averageTime: number
    }>
    peakTrafficHours: Array<{
      hour: number
      requestCount: number
    }>
  }
  errors: Array<{
    timestamp: string
    error: string
    count: number
  }>
}

export async function generateSystemReport(
  env: Env,
  startDate: Date,
  endDate: Date
): Promise<SystemReport> {
  const period = `${startDate.toISOString().split('T')[0]} - ${endDate.toISOString().split('T')[0]}`
  
  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨ˆç®—
  const metrics = await calculateSystemMetrics(env.DB, startDate, endDate)
  const performance = await analyzePerformance(env.DB, startDate, endDate)
  const errors = await getErrorSummary(env.DB, startDate, endDate)
  
  return {
    period,
    metrics,
    performance,
    errors
  }
}

async function calculateSystemMetrics(db: D1Database, start: Date, end: Date) {
  // ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨ˆç®—
  const totalRequests = await db.prepare(`
    SELECT COUNT(*) as count FROM request_logs 
    WHERE timestamp BETWEEN ? AND ?
  `).bind(start.toISOString(), end.toISOString()).first() as { count: number }
  
  const avgResponseTime = await db.prepare(`
    SELECT AVG(response_time) as avg FROM request_logs 
    WHERE timestamp BETWEEN ? AND ?
  `).bind(start.toISOString(), end.toISOString()).first() as { avg: number }
  
  const errorCount = await db.prepare(`
    SELECT COUNT(*) as count FROM request_logs 
    WHERE timestamp BETWEEN ? AND ? AND status_code >= 400
  `).bind(start.toISOString(), end.toISOString()).first() as { count: number }
  
  const activeUsers = await db.prepare(`
    SELECT COUNT(DISTINCT user_id) as count FROM user_activity 
    WHERE last_active BETWEEN ? AND ?
  `).bind(start.toISOString(), end.toISOString()).first() as { count: number }
  
  return {
    uptime: 99.9, // SLAç›£è¦–ã‹ã‚‰å–å¾—
    totalRequests: totalRequests.count,
    averageResponseTime: avgResponseTime.avg || 0,
    errorRate: totalRequests.count > 0 ? (errorCount.count / totalRequests.count) * 100 : 0,
    activeUsers: activeUsers.count
  }
}
```

### ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ©ç”¨çŠ¶æ³ãƒ¬ãƒãƒ¼ãƒˆ
```typescript
// user-analytics-report.ts
export interface UserAnalyticsReport {
  period: string
  userMetrics: {
    totalUsers: number
    activeUsers: number
    newUsers: number
    retentionRate: number
  }
  usageMetrics: {
    averageMedicinesPerUser: number
    averageLogsPerUser: number
    mostUsedFeatures: Array<{
      feature: string
      usage: number
    }>
  }
  adherenceMetrics: {
    overallAdherenceRate: number
    adherenceDistribution: Array<{
      range: string
      userCount: number
    }>
  }
}

export async function generateUserAnalyticsReport(
  env: Env,
  startDate: Date,
  endDate: Date
): Promise<UserAnalyticsReport> {
  const db = drizzle(env.DB)
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒˆãƒªã‚¯ã‚¹
  const totalUsers = await db.select({ count: sql`count(*)` }).from(users).get()
  const activeUsers = await db
    .select({ count: sql`count(*)` })
    .from(users)
    .where(and(
      gte(users.updatedAt, startDate),
      lt(users.updatedAt, endDate)
    ))
    .get()
  
  // æœè–¬éµå®ˆç‡åˆ†æ
  const adherenceData = await calculateAdherenceDistribution(db, startDate, endDate)
  
  return {
    period: `${startDate.toDateString()} - ${endDate.toDateString()}`,
    userMetrics: {
      totalUsers: totalUsers?.count || 0,
      activeUsers: activeUsers?.count || 0,
      newUsers: 0, // å®Ÿè£…çœç•¥
      retentionRate: 0 // å®Ÿè£…çœç•¥
    },
    usageMetrics: {
      averageMedicinesPerUser: 0,
      averageLogsPerUser: 0,
      mostUsedFeatures: []
    },
    adherenceMetrics: {
      overallAdherenceRate: adherenceData.overall,
      adherenceDistribution: adherenceData.distribution
    }
  }
}
```

### é€±æ¬¡/æœˆæ¬¡ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆ
```typescript
// automated-reporting.ts
export async function generateWeeklyReport(env: Env) {
  const endDate = new Date()
  const startDate = new Date(endDate)
  startDate.setDate(startDate.getDate() - 7)
  
  try {
    const systemReport = await generateSystemReport(env, startDate, endDate)
    const userReport = await generateUserAnalyticsReport(env, startDate, endDate)
    
    // ãƒ¬ãƒãƒ¼ãƒˆã‚’Markdownå½¢å¼ã§ç”Ÿæˆ
    const reportMarkdown = generateReportMarkdown(systemReport, userReport)
    
    // ãƒ¬ãƒãƒ¼ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ï¼ˆä¾‹ï¼šR2ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼‰
    await saveReport(env, 'weekly', reportMarkdown)
    
    // ç®¡ç†è€…ã«ãƒ¡ãƒ¼ãƒ«/Slacké€šçŸ¥
    await notifyAdministrators(env, 'weekly', systemReport.metrics)
    
    console.log('âœ… Weekly report generated successfully')
  } catch (error) {
    console.error('âŒ Failed to generate weekly report:', error)
    throw error
  }
}

function generateReportMarkdown(system: SystemReport, user: UserAnalyticsReport): string {
  return `
# é€±æ¬¡é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆ

## ğŸ“Š ã‚·ã‚¹ãƒ†ãƒ ç¨¼åƒçŠ¶æ³
- **ç¨¼åƒç‡**: ${system.metrics.uptime}%
- **ç·ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°**: ${system.metrics.totalRequests.toLocaleString()}
- **å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“**: ${system.metrics.averageResponseTime.toFixed(2)}ms
- **ã‚¨ãƒ©ãƒ¼ç‡**: ${system.metrics.errorRate.toFixed(2)}%

## ğŸ‘¥ ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ©ç”¨çŠ¶æ³
- **ç·ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°**: ${user.userMetrics.totalUsers.toLocaleString()}
- **ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°**: ${user.userMetrics.activeUsers.toLocaleString()}
- **æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°**: ${user.userMetrics.newUsers.toLocaleString()}

## ğŸ’Š æœè–¬ç®¡ç†çŠ¶æ³
- **å…¨ä½“éµå®ˆç‡**: ${user.adherenceMetrics.overallAdherenceRate.toFixed(1)}%
- **éµå®ˆç‡åˆ†å¸ƒ**:
${user.adherenceMetrics.adherenceDistribution
  .map(d => `  - ${d.range}: ${d.userCount}å`)
  .join('\n')}

## âš ï¸ ä¸»è¦ã‚¨ãƒ©ãƒ¼
${system.errors.slice(0, 5)
  .map(e => `- ${e.error}: ${e.count}å›`)
  .join('\n')}

---
*ç”Ÿæˆæ—¥æ™‚: ${new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' })}*
  `
}
```

## ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š

### é–¾å€¤ãƒ™ãƒ¼ã‚¹ã‚¢ãƒ©ãƒ¼ãƒˆ
```typescript
// alerting-system.ts
export interface AlertRule {
  name: string
  metric: string
  threshold: number
  comparison: 'gt' | 'lt' | 'eq'
  duration: number // åˆ†
  severity: 'low' | 'medium' | 'high' | 'critical'
  channels: Array<'slack' | 'email' | 'sms'>
}

const ALERT_RULES: AlertRule[] = [
  {
    name: 'High Error Rate',
    metric: 'error_rate',
    threshold: 5.0,
    comparison: 'gt',
    duration: 5,
    severity: 'high',
    channels: ['slack', 'email']
  },
  {
    name: 'Slow Response Time',
    metric: 'avg_response_time',
    threshold: 1000,
    comparison: 'gt',
    duration: 10,
    severity: 'medium',
    channels: ['slack']
  },
  {
    name: 'Database Connection Issues',
    metric: 'db_connection_errors',
    threshold: 0,
    comparison: 'gt',
    duration: 1,
    severity: 'critical',
    channels: ['slack', 'email', 'sms']
  },
  {
    name: 'LINE API Failures',
    metric: 'line_api_failures',
    threshold: 10,
    comparison: 'gt',
    duration: 5,
    severity: 'high',
    channels: ['slack', 'email']
  }
]

export class AlertManager {
  private env: Env
  private alertHistory: Map<string, Date> = new Map()
  
  constructor(env: Env) {
    this.env = env
  }
  
  async checkAlerts(): Promise<void> {
    for (const rule of ALERT_RULES) {
      try {
        const currentValue = await this.getMetricValue(rule.metric)
        const shouldAlert = this.evaluateRule(rule, currentValue)
        
        if (shouldAlert) {
          await this.sendAlert(rule, currentValue)
        }
      } catch (error) {
        console.error(`Failed to check alert rule ${rule.name}:`, error)
      }
    }
  }
  
  private evaluateRule(rule: AlertRule, value: number): boolean {
    switch (rule.comparison) {
      case 'gt': return value > rule.threshold
      case 'lt': return value < rule.threshold
      case 'eq': return value === rule.threshold
      default: return false
    }
  }
  
  private async getMetricValue(metric: string): Promise<number> {
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹å€¤ã®å–å¾—å®Ÿè£…
    switch (metric) {
      case 'error_rate':
        return await this.calculateErrorRate()
      case 'avg_response_time':
        return await this.calculateAvgResponseTime()
      case 'db_connection_errors':
        return await this.getDbConnectionErrors()
      case 'line_api_failures':
        return await this.getLineApiFailures()
      default:
        return 0
    }
  }
  
  private async sendAlert(rule: AlertRule, value: number): Promise<void> {
    // é‡è¤‡ã‚¢ãƒ©ãƒ¼ãƒˆé˜²æ­¢ï¼ˆåŒã˜ã‚¢ãƒ©ãƒ¼ãƒˆã‚’1æ™‚é–“ä»¥å†…ã«å†é€ã—ãªã„ï¼‰
    const lastAlert = this.alertHistory.get(rule.name)
    const now = new Date()
    
    if (lastAlert && (now.getTime() - lastAlert.getTime()) < 60 * 60 * 1000) {
      return // 1æ™‚é–“ä»¥å†…ã®é‡è¤‡ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚¹ã‚­ãƒƒãƒ—
    }
    
    this.alertHistory.set(rule.name, now)
    
    const alertMessage = this.formatAlertMessage(rule, value)
    
    // å„ãƒãƒ£ãƒ³ãƒãƒ«ã«é€šçŸ¥é€ä¿¡
    for (const channel of rule.channels) {
      switch (channel) {
        case 'slack':
          await this.sendSlackAlert(alertMessage, rule.severity)
          break
        case 'email':
          await this.sendEmailAlert(alertMessage, rule.severity)
          break
        case 'sms':
          await this.sendSmsAlert(alertMessage, rule.severity)
          break
      }
    }
  }
  
  private formatAlertMessage(rule: AlertRule, value: number): string {
    const severityEmoji = {
      low: 'ğŸŸ¡',
      medium: 'ğŸŸ ', 
      high: 'ğŸ”´',
      critical: 'ğŸš¨'
    }
    
    return `${severityEmoji[rule.severity]} **ALERT: ${rule.name}**

` +
           `ãƒ¡ãƒˆãƒªã‚¯ã‚¹: ${rule.metric}
` +
           `ç¾åœ¨å€¤: ${value}
` +
           `é–¾å€¤: ${rule.threshold}
` +
           `é‡è¦åº¦: ${rule.severity}
` +
           `æ™‚åˆ»: ${new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' })}

` +
           `ç¢ºèªURL: https://medicine-liff-api.your-subdomain.workers.dev/health`
  }
  
  private async sendSlackAlert(message: string, severity: string): Promise<void> {
    const webhookUrl = this.env.SLACK_WEBHOOK_URL
    if (!webhookUrl) return
    
    const color = {
      low: '#ffeb3b',
      medium: '#ff9800',
      high: '#f44336',
      critical: '#9c27b0'
    }[severity] || '#gray'
    
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        attachments: [{
          color,
          text: message,
          footer: 'Medicine LIFF App Monitoring',
          ts: Math.floor(Date.now() / 1000)
        }]
      })
    })
  }
  
  private async calculateErrorRate(): Promise<number> {
    // éå»15åˆ†é–“ã®ã‚¨ãƒ©ãƒ¼ç‡ã‚’è¨ˆç®—
    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000)
    
    const result = await this.env.DB.prepare(`
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN status >= 400 THEN 1 ELSE 0 END) as errors
      FROM request_logs 
      WHERE timestamp > ?
    `).bind(fifteenMinutesAgo.toISOString()).first() as {
      total: number
      errors: number
    }
    
    return result.total > 0 ? (result.errors / result.total) * 100 : 0
  }
  
  private async calculateAvgResponseTime(): Promise<number> {
    // éå»15åˆ†é–“ã®å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“
    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000)
    
    const result = await this.env.DB.prepare(`
      SELECT AVG(response_time) as avg
      FROM request_logs 
      WHERE timestamp > ?
    `).bind(fifteenMinutesAgo.toISOString()).first() as { avg: number }
    
    return result.avg || 0
  }
  
  private async getDbConnectionErrors(): Promise<number> {
    // DBæ¥ç¶šã‚¨ãƒ©ãƒ¼æ•°ï¼ˆéå»15åˆ†ï¼‰
    // å®Ÿè£…ã¯ç’°å¢ƒã«å¿œã˜ã¦èª¿æ•´
    return 0
  }
  
  private async getLineApiFailures(): Promise<number> {
    // LINE APIã‚¨ãƒ©ãƒ¼æ•°ï¼ˆéå»15åˆ†ï¼‰
    // å®Ÿè£…ã¯ç’°å¢ƒã«å¿œã˜ã¦èª¿æ•´
    return 0
  }
  
  private async sendEmailAlert(message: string, severity: string): Promise<void> {
    // ãƒ¡ãƒ¼ãƒ«é€šçŸ¥å®Ÿè£…ï¼ˆä¾‹ï¼šSendGridã€SESç­‰ï¼‰
    console.log('Email alert sent:', message)
  }
  
  private async sendSmsAlert(message: string, severity: string): Promise<void> {
    // SMSé€šçŸ¥å®Ÿè£…ï¼ˆä¾‹ï¼šTwilioç­‰ï¼‰
    console.log('SMS alert sent:', message)
  }
}
```

## ğŸ“ é‹ç”¨æ‰‹é †æ›¸

### æ—¥æ¬¡é‹ç”¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
```markdown
# æ—¥æ¬¡é‹ç”¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

## æ¯æœã®ç¢ºèªäº‹é …ï¼ˆ9:00 AMï¼‰
- [ ] ã‚·ã‚¹ãƒ†ãƒ ç¨¼åƒçŠ¶æ³ç¢ºèª
  - [ ] ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆç¢ºèª
  - [ ] æ˜¨å¤œã®Cronå®Ÿè¡ŒçŠ¶æ³ç¢ºèª
  - [ ] ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®ç¢ºèª

- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼å½±éŸ¿ç¢ºèª
  - [ ] æ–°è¦å•ã„åˆã‚ã›ç¢ºèª
  - [ ] ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼é€ä¿¡æˆåŠŸç‡ç¢ºèª
  - [ ] ç•°å¸¸ãªãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ã®æ¤œå‡º

- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç¢ºèª
  - [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“æ¨ç§»ç¢ºèª
  - [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½¿ç”¨é‡ç¢ºèª
  - [ ] CDNã‚­ãƒ£ãƒƒã‚·ãƒ¥åŠ¹ç‡ç¢ºèª

## æ¯å¤•ã®ç¢ºèªäº‹é …ï¼ˆ6:00 PMï¼‰
- [ ] æœ¬æ—¥ã®åˆ©ç”¨çµ±è¨ˆç¢ºèª
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç”ŸçŠ¶æ³ç¢ºèª
- [ ] æ˜æ—¥ã®ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹äºˆå®šç¢ºèª
```

### éšœå®³å¯¾å¿œãƒ•ãƒ­ãƒ¼
```markdown
# éšœå®³å¯¾å¿œãƒ•ãƒ­ãƒ¼

## ãƒ¬ãƒ™ãƒ«1: è»½å¾®ãªå•é¡Œï¼ˆå˜ä¸€æ©Ÿèƒ½ã®è»½å¾®ãªä¸å…·åˆï¼‰
1. **æ¤œçŸ¥** (5åˆ†ä»¥å†…)
   - è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆ or ãƒ¦ãƒ¼ã‚¶ãƒ¼å ±å‘Š
   
2. **åˆæœŸå¯¾å¿œ** (15åˆ†ä»¥å†…)
   - ç¾è±¡ç¢ºèª
   - å½±éŸ¿ç¯„å›²ç‰¹å®š
   - ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼ã¸ã®é€£çµ¡
   
3. **ä¿®æ­£** (1æ™‚é–“ä»¥å†…)
   - åŸå› èª¿æŸ»
   - ä¿®æ­£é©ç”¨
   - å‹•ä½œç¢ºèª

## ãƒ¬ãƒ™ãƒ«2: é‡è¦ãªå•é¡Œï¼ˆä¸»è¦æ©Ÿèƒ½ã®åœæ­¢ï¼‰
1. **æ¤œçŸ¥** (2åˆ†ä»¥å†…)
2. **ç·Šæ€¥å¯¾å¿œ** (5åˆ†ä»¥å†…)
   - éšœå®³çŠ¶æ³ç¢ºèª
   - ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
   - æš«å®šå¯¾å¿œå®Ÿæ–½
3. **æœ¬æ ¼å¯¾å¿œ** (30åˆ†ä»¥å†…)
   - æ ¹æœ¬åŸå› è§£æ±º
   - å…¨é¢å¾©æ—§ç¢ºèª

## ãƒ¬ãƒ™ãƒ«3: ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ï¼ˆã‚µãƒ¼ãƒ“ã‚¹å…¨åœæ­¢ï¼‰
1. **å³åº§å¯¾å¿œ** (1åˆ†ä»¥å†…)
2. **ç·Šæ€¥æ‹›é›†** (3åˆ†ä»¥å†…)
3. **æš«å®šå¾©æ—§** (10åˆ†ä»¥å†…)
4. **å®Œå…¨å¾©æ—§** (1æ™‚é–“ä»¥å†…)
```

### å®šæœŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ‰‹é †
```bash
#!/bin/bash
# monthly-maintenance.sh

echo "ğŸ”§ æœˆæ¬¡ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹é–‹å§‹"

# 1. ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
echo "ğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª..."
curl -f https://medicine-liff-api.your-subdomain.workers.dev/health > /tmp/pre_maintenance_health.json

# 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
echo "ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—..."
node scripts/create-backup.js

# 3. ä¾å­˜é–¢ä¿‚æ›´æ–°
echo "ğŸ“¦ ä¾å­˜é–¢ä¿‚æ›´æ–°..."
npm audit
npm update

# 4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
echo "ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³..."
npm audit --audit-level moderate

# 5. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
echo "âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ..."
npm run test:performance

# 6. ãƒ‡ãƒ—ãƒ­ã‚¤ï¼ˆå¿…è¦ãªå ´åˆï¼‰
if [ "$1" = "--deploy" ]; then
  echo "ğŸš€ ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ãƒ‡ãƒ—ãƒ­ã‚¤..."
  npm run deploy
  
  # ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œã®å‹•ä½œç¢ºèª
  sleep 30
  curl -f https://medicine-liff-api.your-subdomain.workers.dev/health
fi

# 7. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
echo "ğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—..."
node scripts/cleanup-old-logs.js

echo "âœ… æœˆæ¬¡ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹å®Œäº†"
```

---

å‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: [[06_ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ]]
